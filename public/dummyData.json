[{"message":"complete solution for 'kClosest' - O(n) time complexity","filename":"2. medium/kClostestPointsToOrigin.js","daysOld":0,"title":"kClostestPointsToOrigin","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/kClostestPointsToOrigin.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/k-closest-points-to-origin/\n\nWe have a list of points on the plane.\nFind the K closest points to the origin (0, 0).\n\n(Here, the distance between two points on a plane is the Euclidean distance.)\n\nYou may return the answer in any order.\nThe answer is guaranteed to be unique (except for the order that it is in.)\n\n---------------------------------------------------------------------------\n\nExample 1:\n\nInput: points = [[1,3],[-2,2]], K = 1\nOutput: [[-2,2]]\nExplanation: \nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\n\nExample 2:\n\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\nOutput: [[3,3],[-2,4]]\n(The answer [[-2,4],[3,3]] would also be accepted.)\n\nNote:\n\n1 <= K <= points.length <= 10000\n-10000 < points[i][0] < 10000\n-10000 < points[i][1] < 10000\n*/\n\n/**\n * @param {number[][]} points\n * @param {number} K\n * @return {number[][]}\n */\nconst kClosest = (points, K) => {\n    const distanceToOrigin = (point) => (Math.sqrt(point[0] * point[0] + point[1] * point[1]));\n    \n    points.sort((a, b) => (distanceToOrigin(a) - distanceToOrigin(b)));\n    \n    return points.slice(0, K);\n};"},{"message":"complete solution for 'updateBoard' - O(log n) time complexity","filename":"2. medium/minesweeper.js","daysOld":9,"title":"minesweeper","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/minesweeper.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/minesweeper/\n\net's play the minesweeper game (Wikipedia, online game)!\n\nYou are given a 2D char matrix representing the game board.\n'M' represents an unrevealed mine, 'E' represents an unrevealed empty square,\n'B' represents a revealed blank square that has no adjacent\n(above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8')\nrepresents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.\n\nNow given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'),\nreturn the board after revealing this position according to the following rules:\n\nIf a mine ('M') is revealed, then the game is over - change it to 'X'.\nIf an empty square ('E') with no adjacent mines is revealed,\nthen change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.\nIf an empty square ('E') with at least one adjacent mine is revealed,\nthen change it to a digit ('1' to '8') representing the number of adjacent mines.\nReturn the board when no more squares will be revealed.\n \n--------------------------------------------------------------------------------\n\nExample 1:\n\nInput: \n\n[['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'M', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E']]\n\nClick : [3,0]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nExample 2:\n\nInput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nClick : [1,2]\n\nOutput: \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'X', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nNote:\n\nThe range of the input matrix's height and width is [1,50].\nThe click position will only be an unrevealed square ('M' or 'E'),\nwhich also means the input board contains at least one clickable square.\nThe input board won't be a stage when game is over (some mines have been revealed).\nFor simplicity, not mentioned rules should be ignored in this problem.\nFor example, you don't need to reveal all the unrevealed mines when the game is over,\nconsider any cases that you will win the game or flag any squares.\n*/\n\n/**\n * @param {character[][]} board\n * @param {number[]} click\n * @return {character[][]}\n */\nconst updateBoard = (board, click) => {\n    const getSurroundingMineCount = (R, C) => {\n        let total = 0;\n        for (let rDiff = -1; rDiff <= 1; rDiff += 1) {\n            for (let cDiff = -1; cDiff <= 1; cDiff += 1) {\n                if (board[R + rDiff] && board[R+ rDiff][C + cDiff]) {\n                    total += board[R + rDiff][C + cDiff] === 'M' ? 1 : 0;\n                }\n            }\n        }\n        return total;\n    };\n\n    const markSquare = (R, C) => {\n        if (board[R][C] === 'M') {\n            board[R][C] = 'X';\n        } else if (board[R][C] !== 'B') {\n            const mineCount = getSurroundingMineCount(R, C);\n            if (mineCount > 0) {\n                board[R][C] = mineCount.toString();\n            } else {\n                board[R][C] = 'B';\n                for (let rDiff = -1; rDiff <= 1; rDiff += 1) {\n                    for (let cDiff = -1; cDiff <= 1; cDiff += 1) {\n                        if (board[R + rDiff] && board[R + rDiff][C + cDiff]) {\n                            markSquare(R + rDiff, C + cDiff);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    \n    markSquare(...click);\n\n    return board;\n};\n"},{"message":"complete solution for 'exist' - O(n) time complexity","filename":"2. medium/wordSearch.js","daysOld":2,"title":"wordSearch","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/wordSearch.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/word-search/\n\nGiven a 2D board and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell,\nwhere \"adjacent\" cells are those horizontally or vertically neighboring.\nThe same letter cell may not be used more than once.\n\n----------------------------------------------------\n\nExample:\n\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\nGiven word = \"ABCCED\", return true.\nGiven word = \"SEE\", return true.\nGiven word = \"ABCB\", return false.\n \n----------------------------------------------------\n\nConstraints:\n\nboard and word consists only of lowercase and uppercase English letters.\n1 <= board.length <= 200\n1 <= board[i].length <= 200\n1 <= word.length <= 10^3\n*/\n\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nconst exist = (board, word) => {\n    let found = false;\n    \n    const findWord = (R, C, B, idx = 0) => {\n        if(!found && B[R][C] === word[idx]) {\n            if (idx === word.length - 1) {\n                found = true;\n            } else {\n                const temp = B[R][C];\n                B[R][C] = '.';\n                \n                if (B[R + 1] && B[R + 1][C] === word[idx + 1]) {           \n                    findWord(R + 1, C, B, idx + 1);\n                }\n                if (B[R - 1] && B[R - 1][C] === word[idx + 1]) {\n                    findWord(R - 1, C, B, idx + 1);\n                }\n                if (B[R][C + 1] === word[idx + 1]) {\n                    findWord(R, C + 1, B, idx + 1);\n                }\n                if (B[R][C - 1] === word[idx + 1]) {\n                    findWord(R, C - 1, B, idx + 1);\n                }\n                B[R][C] = temp;    \n            }\n        }\n    }\n    \n    for (let row = 0; row < board.length && !found; row += 1) {\n        for (let col = 0; col < board[row].length && !found; col += 1) {\n            if (board[row][col] === word[0]) {\n                findWord(row, col, board);\n            }\n        }\n    }\n    \n    return found;\n};\n"},{"message":"complete solution for 'maxAreaOfIsland' - O(n) time complexity","filename":"2. medium/maxAreaOfIsland.js","daysOld":4,"title":"maxAreaOfIsland","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/maxAreaOfIsland.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/max-area-of-island/\n\nGiven a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land)\nconnected 4-directionally (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nFind the maximum area of an island in the given 2D array.\n(If there is no island, the maximum area is 0.)\n\n----------------------------------------------------\n\nExample 1:\n\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n\nGiven the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.\n\nExample 2:\n\n[[0,0,0,0,0,0,0,0]]\n\nGiven the above grid, return 0.\n\nNote: The length of each dimension in the given grid does not exceed 50.\n*/\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst maxAreaOfIsland = (grid) => {\n    let maxArea = 0;\n\n    const markIsland = (R, C, count) => {\n        if(grid[R] && grid[R][C] && grid[R][C] === 1) {\n            count += 1;\n            if (count > maxArea) {\n                maxArea = count;\n            }\n            grid[R][C] = 0;\n            count = markIsland(R + 1, C, count);\n            count = markIsland(R - 1, C, count);\n            count = markIsland(R, C + 1, count);\n            count = markIsland(R, C - 1, count);\n        }\n        return count;\n    }\n\n    for (let row = 0; row < grid.length; row += 1) {\n        for (let col = 0; col < grid[row].length; col += 1) {\n            if (grid[row][col] === 1) {\n                markIsland(row, col, count = 0);\n            }\n        }\n    }\n\n    return maxArea;\n};"},{"message":"complete solution for 'intToRoman' - O(log n) time complexity","filename":"2. medium/integerToRoman.js","daysOld":6,"title":"integerToRoman","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/integerToRoman.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/integer-to-roman/\n\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, two is written as II in Roman numeral, just two one's added together.\nTwelve is written as, XII, which is simply X + II.\nThe number twenty seven is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right.\nHowever, the numeral for four is not IIII. Instead, the number four is written as IV.\nBecause the one is before the five we subtract it making four.\nThe same principle applies to the number nine, which is written as IX.\nThere are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\nInput is guaranteed to be within the range from 1 to 3999.\n\n-----------------------------------------------------\n\nExample 1:\n\nInput: 3\nOutput: \"III\"\n\nExample 2:\n\nInput: 4\nOutput: \"IV\"\n\nExample 3:\n\nInput: 9\nOutput: \"IX\"\n\nExample 4:\n\nInput: 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n\nExample 5:\n\nInput: 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n*/\n\n/**\n * @param {number} num\n * @return {string}\n */\nconst intToRoman = (num) => {\n    const symbols = [[1000, 'M'], [500, 'D'], [100, 'C'], [50, 'L'], [10, 'X'], [5, 'V'], [1, 'I']];\n    let remainder = num;\n    let stringNumeral = '';\n    \n    for (let i = 0; i < symbols.length, remainder > 0; i += 1) {\n        const currentAmount = symbols[i][0];\n        const currentSymbol = symbols[i][1];\n        const timesCanBeDivided = Math.floor(remainder / currentAmount);\n\n\n        if (howManyCanBeDivided) {        \n            stringNumeral += currentSymbol.repeat(timesCanBeDivided);\n            remainder -= (currentAmount * timesCanBeDivided)\n        }\n\n        if (symbols[i + 1]) {\n            // use the modulus of current index to find next 100, 10, or 1 in symbols array\n            const nextSubAmount = (i % 2 === 0) ? symbols[i + 2][0] : symbols[i + 1][0];           \n        \n            if (remainder - (currentAmount - nextSubAmount) >= 0) {\n                const subSymbol = (i % 2 === 0) ? symbols[i + 2][1] : symbols[i + 1][1];\n\n                stringNumeral += subSymbol + currentSymbol;\n                remainder -= (currentAmount - nextSubAmount);\n            }\n        }\n    }\n    \n    return stringNumeral;\n};"},{"message":"complete solution for 'numTeams' - O(n^3) time complexity","filename":"2. medium/countNumberOfTeams.js","daysOld":8,"title":"countNumberOfTeams","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/countNumberOfTeams.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/count-number-of-teams/\n\nThere are n soldiers standing in a line. Each soldier is assigned a unique rating value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\nChoose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).\nA team is valid if:  (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n---------------------------------------------------\n\nExample 1:\n\nInput: rating = [2,5,3,4,1]\nOutput: 3\nExplanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\nExample 2:\n\nInput: rating = [2,1,3]\nOutput: 0\nExplanation: We can't form any team given the conditions.\n\nExample 3:\n\nInput: rating = [1,2,3,4]\nOutput: 4\n \nConstraints:\n\nn == rating.length\n1 <= n <= 200\n1 <= rating[i] <= 10^5\n*/\n\n/**\n * @param {number[]} rating\n * @return {number}\n */\nconst numTeams = (rating) => {\n    let count = 0;\n\n    const validTeam = (A, B, C) => ((A > B && B > C) || (A < B && B < C));\n    \n    for (let i = 0; i < rating.length - 2; i += 1) {\n        for (let j = i + 1; j < rating.length - 1; j += 1) {\n            for (let k = j + 1; k < rating.length; k += 1) {\n                if (validTeam(rating[i], rating[j], rating[k])) {\n                    count += 1;\n                }\n            }\n        }\n    }\n    \n    return count;\n};\n"},{"message":"complete solution for 'isValidSudoku' - O(n^2) time complexity","filename":"2. medium/validSudoku.js","daysOld":9,"title":"validSudoku","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/validSudoku.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/valid-sudoku/\n\nDetermine if a 9x9 Sudoku board is valid.\nOnly the filled cells need to be validated according to the following rules:\n\nEach row must contain the digits 1-9 without repetition.\nEach column must contain the digits 1-9 without repetition.\nEach of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\nA partially filled sudoku which is valid.\n\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n\n------------------------------------------\n\nExample 1:\n\nInput:\n[\n  [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\nOutput: true\n\nExample 2:\n\nInput:\n[\n  [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n  [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n  [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n  [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n  [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n  [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n  [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n  [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n  [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being \n    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\nNote:\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\nOnly the filled cells need to be validated according to the mentioned rules.\nThe given board contain only digits 1-9 and the character '.'.\nThe given board size is always 9x9.\nAccepted\n*/\n\n/**\n * @param {character[][]} board\n * @return {boolean}\n */\n\nconst isValidSudoku = (board) => {\n    // create an array containing string digits 1 - 9\n    const digits = board.map((row, index) => ((index + 1).toString()));\n\n    // write 3 separate functions to look for duplicates\n    // in a given row, column, or subGrid\n    const checkRow = (index) => {\n        let result = true;\n\n        digits.forEach((digit) => {\n            if (board[index].indexOf(digit) !== board[index].lastIndexOf(digit)) {\n                result = false;\n            }\n        });\n        \n        return result;\n    }\n\n    const checkColumn = (index) => {\n        let result = true;\n        // create a new array for all chars from each row at\n        // the current index\n        const column = board.map((row) => (row[index]));\n\n        digits.forEach((digit) => {\n            if (column.indexOf(digit) !== column.lastIndexOf(digit)) {\n                result = false;\n            }\n        });\n\n        return result;\n    }\n\n    const checkSubGrid = (index) => {\n        // convert index to one of 9 subGrids in which\n        // duplicates are not allowed\n        const startRow = Math.floor((index) / 3) * 3;\n        const startColumn = ((index) % 3) * 3;\n\n        let subGrid = [];\n\n        // fill subGrid array with 9 values from current subGrid\n        for (let row = startRow; row < startRow + 3; row += 1) {\n            subGrid = subGrid.concat(board[row].slice(startColumn, startColumn + 3));\n        }\n\n        let result = true;\n\n        digits.forEach((digit) => {\n            if (subGrid.indexOf(digit) !== subGrid.lastIndexOf(digit)) {\n                result = false;\n            }\n        });\n\n        return result;\n    }\n\n    for (let i = 0; i < board.length; i += 1) {\n        if (!checkRow(i) || !checkColumn(i) || !checkSubGrid(i)) {\n            return false;\n        }\n    }\n\n    return true;\n};"},{"message":"complete solution for 'getMaximumGold' - O(n) time complexity","filename":"2. medium/pathWithMaximumGold.js","daysOld":9,"title":"pathWithMaximumGold","url":"https://github.com/seth-way/algorithms/blob/master/2.%20medium/pathWithMaximumGold.js","difficulty":"Medium","body":"/*\nhttps://leetcode.com/problems/path-with-maximum-gold/\n\nIn a gold mine grid of size m * n, each cell in this mine has an integer representing\nthe amount of gold in that cell, 0 if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\nEvery time you are located in a cell you will collect all the gold in that cell.\nFrom your position you can walk one step to the left, right, up or down.\nYou can't visit the same cell more than once.\nNever visit a cell with 0 gold.\nYou can start and stop collecting gold from any position in the grid that has some gold.\n\n-------------------------------------------------\n\nExample 1:\n\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n\nExample 2:\n\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n*/\n\n/* eslint-disable no-undef */\n/* eslint-disable no-param-reassign */\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst getMaximumGold = (grid) => {\n  let maxGold = 0;\n\n  const searchForGold = (row, column, sum) => {\n    if (grid[row] && grid[row][column]) {\n      const gold = grid[row][column];\n\n      if (sum + gold > maxGold) {\n        maxGold = sum + gold;\n      }\n\n      grid[row][column] = 0;\n\n      searchForGold(row + 1, column, sum + gold);\n      searchForGold(row - 1, column, sum + gold);\n      searchForGold(row, column + 1, sum + gold);\n      searchForGold(row, column - 1, sum + gold);\n\n      grid[row][column] = gold;\n    }\n  };\n\n  for (let row = 0; row < grid.length; row += 1) {\n    for (let col = 0; col < grid[row].length; col += 1) {\n      searchForGold(row, col, foundGold = 0);\n    }\n  }\n\n  return maxGold;\n};\n"},{"message":"complete solution for 'tictactoe' - O(n) time complexity","filename":"1. easy/findWinnerInATicTacToeGame.js","daysOld":10,"title":"findWinnerInATicTacToeGame","url":"https://github.com/seth-way/algorithms/blob/master/1.%20easy/findWinnerInATicTacToeGame.js","difficulty":"Easy","body":"/*\nhttps://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/\n\nTic-tac-toe is played by two players A and B on a 3 x 3 grid.\n\nHere are the rules of Tic-Tac-Toe:\n\nPlayers take turns placing characters into empty squares (\" \").\nThe first player A always places \"X\" characters,\nwhile the second player B always places \"O\" characters.\n\"X\" and \"O\" characters are always placed into empty squares, never on filled ones.\nThe game ends when there are 3 of the same (non-empty) character\nfilling any row, column, or diagonal.\nThe game also ends if all squares are non-empty.\nNo more moves can be played if the game is over.\nGiven an array moves where each element is another array of size 2\ncorresponding to the row and column of the grid where they mark their respective character\nin the order in which A and B play.\n\nReturn the winner of the game if it exists (A or B),\nin case the game ends in a draw return \"Draw\",\nif there are still movements to play return \"Pending\".\n\nYou can assume that moves is valid (It follows the rules of Tic-Tac-Toe),\nthe grid is initially empty and A will play first.\n\n--------------------------------------------------------\n\nExample 1:\n\nInput: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\nOutput: \"A\"\nExplanation: \"A\" wins, he always plays first.\n\"X  \"    \"X  \"    \"X  \"    \"X  \"    \"X  \"\n\"   \" -> \"   \" -> \" X \" -> \" X \" -> \" X \"\n\"   \"    \"O  \"    \"O  \"    \"OO \"    \"OOX\"\n\nExample 2:\n\nInput: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\nOutput: \"B\"\nExplanation: \"B\" wins.\n\"X  \"    \"X  \"    \"XX \"    \"XXO\"    \"XXO\"    \"XXO\"\n\"   \" -> \" O \" -> \" O \" -> \" O \" -> \"XO \" -> \"XO \"\n\"   \"    \"   \"    \"   \"    \"   \"    \"   \"    \"O  \"\n\nExample 3:\n\nInput: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\nOutput: \"Draw\"\nExplanation: The game ends in a draw since there are no moves to make.\n\"XXO\"\n\"OOX\"\n\"XOX\"\n\nExample 4:\n\nInput: moves = [[0,0],[1,1]]\nOutput: \"Pending\"\nExplanation: The game has not finished yet.\n\"X  \"\n\" O \"\n\"   \"\n*/\n\n/**\n * @param {number[][]} moves\n * @return {string}\n */\n\nconst tictactoe = (moves) => {\n  const grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n  let player = 1;\n\n  const markGrid = (row, column, whosTurn) => {\n    grid[row][column] = whosTurn;\n  };\n\n  for (let i = 0; i < moves.length; i += 1) {\n    markGrid(moves[i][0], moves[i][1], player);\n    player *= -1;\n  }\n\n  const diag1 = grid[0][0] + grid[1][1] + grid[2][2];\n  const diag2 = grid[2][0] + grid[1][1] + grid[0][2];\n\n  if (diag1 === 3 || diag2 === 3) {\n    return 'A';\n  }\n\n  if (diag1 === -3 || diag2 === -3) {\n    return 'B';\n  }\n\n  for (let i = 0; i < grid.length; i += 1) {\n    const rowSum = grid[i].reduce((acc, val) => (acc + val), 0);\n\n    if (rowSum === 3) {\n      return 'A';\n    }\n    if (rowSum === -3) {\n      return 'B';\n    }\n\n    let colSum = 0;\n\n    grid.forEach((row) => {\n      colSum += row[i];\n    });\n\n    if (colSum === 3) {\n      return 'A';\n    }\n    if (colSum === -3) {\n      return 'B';\n    }\n  }\n\n  return moves.length === 9 ? 'Draw' : 'Pending';\n};\n"},{"message":"complete working solution for 'islandPerimeter' - O(n) time complexity","filename":"1. easy/islandPerimeter.js","daysOld":11,"title":"islandPerimeter","url":"https://github.com/seth-way/algorithms/blob/master/1.%20easy/islandPerimeter.js","difficulty":"Easy","body":"// https://leetcode.com/problems/island-perimeter/\n\n/*\nYou are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.\n\nGrid cells are connected horizontally/vertically (not diagonally).\nThe grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes\" (water inside that isn't connected to the water around the island).\nOne cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100.\nDetermine the perimeter of the island.\n\n---------------------------------\n\nExample:\n\nInput:\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\nOutput: 16\n*/\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\n\nconst islandPerimeter = (grid) => {\n    let totalPerimeter = 0;\n    \n    const checkSquare = (row, column) => {\n        if(!grid[row] || !grid[row][column]) {\n            totalPerimeter += 1\n        } else if (grid[row][column] === 1) {\n            grid[row][column] = -1;\n            checkSquare(row + 1, column);\n            checkSquare(row - 1, column);\n            checkSquare(row, column + 1);\n            checkSquare(row, column - 1);\n            \n        } \n    }\n    \n    for (let i = 0; i < grid.length; i += 1) {\n        for(let j = 0; j < grid[0].length; j += 1) {\n            if (grid[i][j] === 1) {\n                checkSquare(i, j);\n                return totalPerimeter;\n            }\n        }\n    }\n};"},{"message":"complete solution for 'getHint' - O(n) time complexity","filename":"1. easy/bullsAndCows.js","daysOld":11,"title":"bullsAndCows","url":"https://github.com/seth-way/algorithms/blob/master/1.%20easy/bullsAndCows.js","difficulty":"Easy","body":"/*\nhttps://leetcode.com/problems/bulls-and-cows/\n\nYou are playing the following Bulls and Cows game with your friend:\n    You write down a number and ask your friend to guess what the number is.\n    Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly\n    in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\").\n    Your friend will use successive guesses and hints to eventually derive the secret number.\n\nWrite a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. \n\nPlease note that both secret number and friend's guess may contain duplicate digits.\n\n--------------------------------------------------------------\n\nExample 1:\n\nInput: secret = \"1807\", guess = \"7810\"\n\nOutput: \"1A3B\"\n\nExplanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n\nExample 2:\n\nInput: secret = \"1123\", guess = \"0111\"\n\nOutput: \"1A1B\"\n\nExplanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n*/\n\n/**\n * @param {string} secret\n * @param {string} guess\n * @return {string}\n */\n\nconst getHint = (secret, guess) => {\n    if (secret === guess) {\n        return secret.length + 'A0B';\n    }\n    \n    let [bulls, cows] = [0, 0];\n\n    // both extraDigit arrays will store counts for all non-bull digits\n    // where array[digit] = count\n    let secretExtraDigits = new Array(10);\n    let guessExtraDigits = new Array(10);\n    \n    for (let i = 0; i < secret.length; i += 1) {\n        if (secret[i] === guess[i]) {\n            bulls += 1;\n        } else {    \n            if (secretExtraDigits[secret[i]]) {\n                secretExtraDigits[secret[i]] += 1;\n            } else {\n                secretExtraDigits[secret[i]] = 1;\n            }\n            \n            if (guessExtraDigits[guess[i]]) {\n                guessExtraDigits[guess[i]] += 1;\n            } else {\n                guessExtraDigits[guess[i]] = 1;\n            }\n        }\n    }\n    \n    for (let i = 0; i < 10; i += 1) {\n        let a = secretExtraDigits[i] ? secretExtraDigits[i] : 0;\n        let b = guessExtraDigits[i] ? guessExtraDigits[i] : 0;\n\n        // a cow will be counted in both a && b, so we increment\n        // the cows count by the minumum of a & b\n        cows += Math.min(a, b);\n    }\n    \n    return bulls + 'A' + cows + 'B';\n};"}]
